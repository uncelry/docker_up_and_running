### cgroups (контрольные группы)
Они нужны для ограничения ресурсов контейнеров

Чтобы найти cgroup контейнера докер:
`ls /sys/fs/cgroup/system.slice/docker-<long-container-id>.scope -la`

Подробности тут (https://docs.docker.com/engine/containers/runmetrics/#find-the-cgroup-for-a-given-container)

Файлы внутри можно менять для изменения ресурсов контейнеров налету, но не стоит так делать. 
Лучше использовать `docker container update`, или `docker container run --cgroup-parent` (для указания группы)

### namespaces (пространства имен)
Нужны для отделения пространства контейнеров от пространства хост-системы

Чтобы увидеть процессы в контейнере с точки зрения хост-системы: `docker container top 13ce8e8b6a`

Можем использовать пространство имен хоста, например, для пространства процессов: 
`docker container run --pid=host spkane/train-os ps -ef`

### Безопасность
Не следует запускать контейнеры по uid0 (root). Надо либо в dockerfile `USER not-root-user`, либо при запуске 
`docker container run --rm -u 500 spkane/train-os:latest whoami`

Для самого демона стоит использовать `rootless` режим (надо включить)

### Привилегированные контейнеры
Иногда контейнерам нужны спец привилегии (capabilities) в ядре - можно выдать все: 
`docker container run --it --rm --priveleged=true ubuntu:latest bash`

Можно выдать определенные: `docker container run --it --rm --cap-add=NET_ADMIN ubuntu:latest bash`

Можно удалить определенные: `docker container run --it --rm --cap-drop=NET_RAW ubuntu:latest bash`

Лучше использовать в таких случаях `seccomp` (Secure Computing Mode) - позволяет очень тонко (по системным вызовам) 
настроить привилегии выше. \
Для начала, получаем стандартную политику (она используется по умолчанию) - 
`wget https://raw.githubusercontent.com/moby/moby/refs/heads/master/profiles/seccomp/default.json` \
`cp default.json custom.json`\
Удаляем из файла все лишние системные вызовы для нужных привилегий и запускаем контейнер с новой политикой и нужными 
привилегиями: 
`docker container run --it --rm --security-opt seccomp=custom.json --cap-add=SYS_ADMIN ubuntu:latest bash`

В идеале, не использовать привилегии вообще

### SELinux и AppArmor
Эти 2 взаимозаменяемые системы защиты позволяют увеличить безопасность приложения. По умолчанию docker настроен
на использование одной из систем (можно узнать в выводе `docker system info`). С помощью этих систем можно
запретить любым пользователям (даже root) получать доступ к части системы - к примеру, к `/proc` или `/sys`

AppArmor лучше поддерживается Docker

### Безопасность демона Docker
По умолчанию, демон Docker закрыт для сети (по-хорошему, так и должно быть в рабочем окружении). У него открыт только
локальный сокет Docker. Планировщики с Docker взаимодействуют через unix сокеты демона.

Если порт все же нужно открыть у демона, то нужно использовать шифрование и аутентификацию

### Сети
`docker-proxy` - по процессу на каждый проброшенный порт из контейнера. Он отвечает за перенаправление трафика в
проброшенных портах

При создании контейнера (с драйвером bridge) создается 2 сетевых интерфейса - 1 на стороне сервера (прикреплен к 
мосту `docker0`), и 1 в пространстве имен контейнера

**Входящий трафик** (при драйвере сети bridge) - поступает на интерфейс сервера `eth0`, затем через `docker-proxy`
перенаправляется в нужный контейнер через интерфейс `docker0`.

**Исходящий трафик** (при драйвере сети bridge) - через интерфейс `docker0` направляется в `NAT`, затем на интерфейс
сервера `eth0`, и уходит в сеть

Посмотреть сетевые интерфейсы и их настройки можно командой `ip addr show`

Можно поменять прокси на другой через опцию `--userland-proxy=<path>`, либо выключить вообще - `--userland-proxy=false`,
тогда трафик будет перенаправляться при помощи Hairpin NAT (высокая пропускная способность)

Можно использовать сеть хоста в обход сети Docker - это позволит увеличить пропускную способность сети, но
представит уязвимости безопасности - `docker container run --rm -it --net=host ubuntu:latest ip addr show`

В docker имеется несколько драйверов сетей. С ними можно создавать новые сети и удалять созданные сети:

- `bridge` - сеть с использованием docker-proxy (или кастомные прокси), либо с Hairpin NAT (если отключить proxy)
- `host` - сеть хоста
- `none` - без доступа к сети
- `overlay` - используется в режиме Swarm, чтобы настроить сеть между всеми контейнерами поверх реальной сети
- `macvlan` - создает реальный MAC-адрес для каждого контейнера и предоставляет его по сети через выбранный интерфейс

Посмотреть список сетей `docker network ls`

Посмотреть данные о сети `docker network inspect <network_id>`

Создать сеть с драйвером `docker network create -d macvlan --subnet=172.16.16.0/24 
--gateway=172.16.16.1 -o parent=eth0 ourvlan`

Можно запретить Docker назначать конкретные выбранные адреса через `--aux-address`

### Хранилище
Backend хранилища используется для работы с образами, слоями, сборками и т.д.

Поддерживаются разные варианты, стандартное - `overlay2`. Из производительных есть еще `ZFS`. Backend хранилища
должен поддерживаться хост-системой

Настраивать backend хранилища можно с помощью `daemon.json` или через `dockerd --storage-driver=devicemapper` (например)

Узнать текущий backend хранилища можно через `docker system info`

### nsenter
Используется для входа в пространства имен контейнеров (как альтернатива `docker container exec`). Это более
низкоуровневая команда (не докера, а самой linux)

`docker container run --rm -it --priveleged --pid=host debian nsenter --target 2721 --all` - запустить 
контейнер для отладки другого контейнера (с PID 2721). Это запустит новый контейнер, в котором мы 
войдем в пространство имен контейнера с PID 2721

`docker container run --rm -it --pid=container:container-name-to-debug 
--net=container:container-name-to-debug --cap-add sys_ptrace --cap-add sys_admin ubuntu:latest /bin/bash` - запуск
отладочного контейнера в пространстве имен контейнера без командной оболочки

### Структура docker
Всего Docker состоит из 5-ти компонентов:
- `dockerd` - демон, связующее звено docker. 1 на сервер
- `containerd` - работает с контейнерами, управляет их жизненным циклом. 1 на сервер
- `docker-proxy` - прокси докера, 1 на правило проброса портов
- `containerd-shim-runc-v2` - отвечает за дескрипторы файлов, переданные контейнеру (stdin/out). 1 на контейнер
- `runc` - создает контейнер, выполняет его, собирает статистику и т.д.

При запуске контейнера:\
`dockerd` получает образы, запускает `docker-proxy` (при необходимости), запускает `containerd`. `containerd` собирает 
bundle, передает этот bundle (контейнер docker по стандарту OCI) утилите `runc`. `runc` запускает контейнер, и передает 
его `conteinerd-shim-runc-v2`

Можно использовать runc (это среда выполнения Docker), как низкоуровневый инструмент для работы с контейнерами (например
для получения данных/статистики о нем).

`sudo runc --root /run/docker/runtime-runc/moby list` - получить список контейнеров (бандлов) runc

`sudo ls -la /run/docker/containerd/ccbf4195c628f90eadbaa2f16c4635895b3458f6f166ff0f709a4848a1003e60` - получить каналы 
бандла

`sudo ls -la 
/run/containerd/io.containerd.runtime.v2.task/moby/ccbf4195c628f90eadbaa2f16c4635895b3458f6f166ff0f709a4848a1003e60` -
получить каталог с дополнительными файлами runc, связанными с контейнером (бандлом)

### Альтернативные среды выполнения
Можно использовать альтернативные среды выполнения (аналоги runc) - например, gVisor. Устанавливается отдельно, дает
возможность исполнять контейнеры на стороне конечного пользователя (огромный плюс безопасности, полезен когда 
выполняется непроверенный код)

Подключается альтернативная среда через: `docker container run --rm --runtime=runsc -it alpine /bin/sh`
